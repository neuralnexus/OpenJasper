<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (C) 2005-2023. Cloud Software Group, Inc. All Rights Reserved.
  ~ http://www.jaspersoft.com.
  ~
  ~ Unless you have purchased a commercial license agreement from Jaspersoft,
  ~ the following license terms apply:
  ~
  ~ This program is free software: you can redistribute it and/or modify
  ~ it under the terms of the GNU Affero General Public License as
  ~ published by the Free Software Foundation, either version 3 of the
  ~ License, or (at your option) any later version.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  ~ GNU Affero General Public License for more details.
  ~
  ~ You should have received a copy of the GNU Affero General Public License
  ~ along with this program. If not, see <http://www.gnu.org/licenses/>.
  -->

<beans profile="jrs"
       xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="virtualDataSourceHandler" class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.VirtualDataSourceHandler" lazy-init="true">
        <property name="repositoryService">
             <ref bean="${bean.repositoryService}"/>
        </property>
        <property name="virtualDataSourceQueryService" ref="teiidVirtualQueryService"/>
        <property name="profileAttributesResolver" ref="profileAttributesResolver"/>
        <property name="customReportDataSourceServiceFactory" ref="customDataSourceServiceFactory"/>
    </bean>

    <bean id="abstractTeiidVirtualQueryService" class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.impl.TeiidVirtualDataSourceQueryServiceImpl" abstract="true" lazy-init="true">
        <property name="virtualReportDataSourceServiceFactory"><ref bean="virtualDataSourceServiceFactory"/></property>
        <property name="memoryConfig"><ref bean="teiidMemoryConfig"/></property>
        <property name="teiidCacheFactory" ref="teiidCacheFactory"/>
        <property name="transactionManagerConfiguration"><ref bean="transactionManagerConfiguration"/></property>
        <property name="serverConfig"><ref bean="serverConfig"/></property>
        <property name="engineService"><ref bean="engineService"/></property>
        <property name="repositoryService"><ref bean="${bean.repositoryService}"/></property>
        <property name="poolTimeoutInMinute" value="20"/>
        <property name="athenaPoolTimeoutInMinute" value="45"/>
        <property name="useSubDSTableList" value="true"/>
        <property name="virtualDataSourceConfigList">
            <list>
                <!-- bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.VirtualDataSourceConfig">
                    <property name="dataSourceURI" value="/organizations/organization_1/datasources/BigDataConnectors"/>
                    <property name="additionalDataSourceList">
                        <list>
                            <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.impl.MongoDBTeiidConnectorImpl">
                                <property name="dataSourceName" value="MongoDB" />
                                <property name="remoteServerList" value="127.0.0.1:27017" />
                                <property name="schemaText" value="CREATE FOREIGN TABLE student_scores(id varchar(25), student_id integer, state varchar(25), score integer) OPTIONS(UPDATABLE 'TRUE');" />
                                <property name="database" value="test" />
                            </bean>
                        </list>
                    </property>
                </bean -->
            </list>
        </property>

        <property name="defaultTranslatorConfig"><ref bean="defaultTranslatorConfig"/></property>
        <property name="translatorConfigList">
            <list>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="oracle"/>
                    <property name="translatorName" value="oracle"/>
                    <property name="translatorFactoryClass" value="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TeiidOracleExecutionFactory"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="postgresql"/>
                    <property name="translatorName" value="postgresql"/>
                    <property name="translatorFactoryClass" value="org.teiid.translator.jdbc.postgresql.PostgreSQLExecutionFactory"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="Microsoft SQL Server"/>
                    <property name="translatorName" value="sqlserver"/>
                    <property name="translatorFactoryClass" value="org.teiid.translator.jdbc.sqlserver.SQLServerExecutionFactory"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="db2"/>
                    <property name="translatorName" value="db2"/>
                    <property name="translatorFactoryClass" value="org.teiid.translator.jdbc.db2.DB2ExecutionFactory"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="ingres"/>
                    <property name="translatorName" value="ingres"/>
                    <property name="translatorFactoryClass" value="org.teiid.translator.jdbc.ingres.IngresExecutionFactory"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="metamatrix"/>
                    <property name="translatorName" value="metamatrix"/>
                    <property name="translatorFactoryClass" value="org.teiid.translator.jdbc.mm.MetaMatrixExecutionFactory"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="vertica database"/>
                    <property name="translatorName" value="vertica"/>
                    <property name="translatorFactoryClass" value="org.teiid.translator.jdbc.vertica.VerticaExecutionFactory"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="mysql"/>
                    <property name="translatorName" value="mysql5"/>
                    <property name="translatorFactoryClass" value="org.teiid.translator.jdbc.mysql.MySQL5ExecutionFactory"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="hive"/>
                    <property name="translatorName" value="hive"/>
                    <property name="translatorFactoryClass" value="org.teiid.translator.hive.HiveExecutionFactory"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="Impala"/>
                    <property name="translatorName" value="impala"/>
                    <property name="translatorFactoryClass" value="org.teiid.translator.hive.ImpalaExecutionFactory"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="Spark"/>
                    <property name="translatorName" value="Spark"/>
                    <property name="translatorFactoryClass" value="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TeiidHiveExecutionFactory"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="adaptive server enterprise"/>
                    <property name="translatorName" value="sybase"/>
                    <property name="translatorFactoryClass" value="org.teiid.translator.jdbc.sybase.SybaseExecutionFactory"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="mongodb"/>
                    <property name="translatorName" value="mongodb-jdbc"/>
                    <property name="translatorFactoryClass" value="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.translator.jdbc.mongodb.MongoDBExecutionFactory"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="googlebigquery"/>
                    <property name="translatorName" value="googlebigquery-jdbc"/>
                    <property name="translatorFactoryClass" value="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.translator.jdbc.googlebigquery.GoogleBigQueryExecutionFactory"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="elastic"/>
                    <property name="translatorName" value="elasticsearch-jdbc"/>
                    <property name="translatorFactoryClass" value="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.translator.jdbc.elasticsearch.ElasticsearchExecutionFactory"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="AWS.Athena"/>
                    <property name="translatorName" value="awsathena-jdbc"/>
                    <property name="translatorFactoryClass" value="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.translator.jdbc.aws.athena.AWSAthenaExecutionFactory"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig">
                    <property name="productName" value="Snowflake"/>
                    <property name="translatorName" value="snowflake-jdbc"/>
                    <property name="translatorFactoryClass" value="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.translator.jdbc.snowflake.SnowflakeExecutionFactory"/>
                </bean>
            </list>
        </property>


        <!-- The property customSelectedSchemas is used to provide the configuration for adding schemas explicitly based on database or datasource name.
 the entry key "usernameAsSchema" will allow to use 'username' as the schema, and if some specific schemas(which is accessible by the datasource user) needs to be included, the entry "schemasToBeIncluded" can be used to include those schema names there. Also, if the username is not used as schema then comment out the "usernameAsSchema" entry.
 -->
        <property name="customSelectedSchemas">
            <map>
                <entry key="oracle">
                    <map>
                        <entry key="usernameAsSchema">
                            <set value-type="java.lang.String">
                                <value></value> <!-- username will be used as schema here -->
                            </set>
                        </entry>
                        <!-- if only specific schema(s) needs to included for this DB then
                        uncomment the below entry and add the schemas to be included-->
                        <!--<entry key="schemasToBeIncluded">
                            <set value-type="java.lang.String">
                                <value>[schema1]</value>
                                <value>[schema2]</value>
                            </set>
                        </entry>-->
                    </map>
                </entry>
            </map>
        </property>

        <property name="importPropertyMap">
            <map>
                <!--  workaround for bug JRS-11028 -->
                <!-- skip system table when using postgres driver version 9.4-1210.jdbc41 -->
                <entry key="postgresql">
                        <map>
                            <entry key="importer.tableTypes" value="TABLE,VIEW,SYNONYM,PARTITIONED TABLE"/>
                        </map>
                </entry>
                <entry key="awsathena-jdbc">
                    <map>
                        <entry key="importer.tableTypes" value="EXTERNAL_TABLE,MANAGED_TABLE,TABLE,VIEW"/>
                    </map>
                </entry>

                <!-- ImportKeys and ImportForeignKeys properties can be set to "false" when it takes longer time to open/edit a VDS based domain.
                Below properties will avoid fetching datasource primary and foreign keys to create a VDS instance,
                note: This entry will affect auto-joins feature of the domain. -->

                <entry key="default">
                    <map>
                        <entry key="importer.importForeignKeys" value="true"/>
                        <entry key="importer.importKeys" value="true"/>
                    </map>
                </entry>
            </map>
        </property>



        <!--  map custom data source to teiid data source -->
        <property name="dataSourceServiceToTeiidConnectorMap">
            <map>
                <!--  entry key="com.jaspersoft.cassandra.jasperserver.CassandraDataSourceService">
                    <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.impl.CassandraTeiidConnectorImpl">
                    </bean>
                </entry>
                <entry key="com.jaspersoft.hadoop.hive.jasperserver.HiveDataSourceService">
                    <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.impl.HiveTeiidConnectorImpl">
                    </bean>
                </entry>
                <entry key="com.jaspersoft.mongodb.jasperserver.MongoDbDataSourceService">
                    <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.impl.MongoDBTeiidConnectorImpl">
                    </bean>
                </entry -->
            </map>
        </property>

        <property name="logConfigList">
            <list>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.LogConfig">
                    <property name="LogContext" value="org.teiid.CONNECTOR"/>
                    <property name="LogLevel" value="DETAIL"/>
                </bean>
                <bean class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.LogConfig">
                    <property name="LogContext" value="org.teiid.RUNTIME"/>
                    <property name="LogLevel" value="DETAIL"/>
                </bean>
            </list>
        </property>

        <!-- uncomment to make objects of these types available in VDS -->
        <!-- by default only object of type TABLE are available -->
        <!-- possible values are the ones returned by java.sql.DatabaseMetaData.getTableTypes() -->
        <property name="databaseObjectTypesFilter">
            <set>
                <value>TABLE</value>
                <!--<value>VIEW</value>-->
                <value>EXTERNAL_TABLE</value><!--This value has been added for AWS athena-->
            </set>
        </property>
    </bean>

    <bean id="defaultTranslatorConfig" class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig" lazy-init="true">
        <property name="productName" value="generic"/>
        <property name="translatorName" value="jdbc-simple"/>
        <property name="translatorFactoryClass" value="org.teiid.translator.jdbc.SimpleJDBCExecutionFactory"/>
    </bean>

    <bean id="teiidMemoryConfig" class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.impl.TeiidMemoryConfigImpl" lazy-init="true">
        <!-- disk storage directory -->
        <!-- property name="diskDirectory" value="temp"/ -->
        <!-- enable disk storage  -->
        <property name="useDisk" value="true"/>
        <!--
        Usage of extremely large VM sizes and or datasets requires additional considerations. Teiid has a non-negligible
        amount of overhead per batch/table page on the order of 100-200 bytes. Depending on the data types involved each
        full batch/table page will represent a variable number of rows (a power of two multiple above or below the
        processor batch size). If you are dealing with datasets with billions of rows and you run into OutOfMemory
        issues, consider increasing the processor-batch-size to force the allocation of larger batches and table pages
        -->
        <property name="processorBatchSize" value="256"/>
        <!-- the batch size to use when reading data from a connector -->
        <!-- property name="connectorBatchSize" value="512"/ -->
        <!-- max open files for caching in cache directory -->
        <property name="maxOpenFiles" value="64"/>
        <!-- the max file size (in MB) (default 2048MB) -->
        <property name="maxFileSize" value="2048"/>
        <!--
        setting determines the total size in kilobytes of batches that can be used by one active plan may be in addition
        to the memory held based on max-reserve-kb. Typical minimum memory required by Teiid when all the active plans
        are active is #active-plans*max-processing-kb. The default value of -1 will auto-calculate a typical max based
        upon the max heap available to the VM and max active plans. The auto-calculated value assumes a 64bit
        architecture and will limit processing batch usage to 10% of memory beyond the first 300 megabytes (which are
        assumed for use by the AS and other Teiid purposes)
        -->
        <property name="maxProcessingKb" value="-1"/>
        <!--
        setting determines the total size in kilobytes of batches that can be held by the BufferManager in memory.
        This number does not account for persistent batches held by soft (such as index pages) or weak references.
        The default value of -1 will auto-calculate a typical max based upon the max heap available to the VM.
        The auto-calculated value assumes a 64bit architecture and will limit buffer usage to 50% of the first
        gigabyte of memory beyond the first 300 megabytes (which are assumed for use by the AS and other Teiid purposes)
        and 75% of the memory beyond that.
        -->
        <property name="maxReserveKb" value="-1"/>
        <!--
        get the max amount of buffer space for caching (file storage) in MB
        For table page and result batches the buffer manager will we a limited number of files that are dedicated to
        a particular storage size. However, as mentioned in the installation, creation of Teiid lob values (for example
        through SQL/XML) will typically create one file per lob once the lob exceeds the allowable in memory size of
        8KB. In heavy usage scenarios, consider pointing the buffer directory on a partition that is routinely
        defragmented. By default Teiid will use up to 50GB of disk space. This is tracked in terms of the number of
        bytes written by Teiid. For large data sets, you may need to increase the max-buffer-space setting.
        -->
        <property name="maxBufferSpace" value="51200"/>
        <!-- persisted inline lobs in file storage -->
        <property name="inlineLobs" value="true"/>
        <!--
        the memory space for caching (in MB)
        set the value to -1 for using approximately 25% of what's set aside for the reserved (default -1)
        -->
        <property name="memoryBufferSpace" value="-1"/>
        <!--
        the max storage size for object (in byte)
        This represents the individual batch page size. If the processor-batch-size is increased and/or you are dealing
        with extremely wide result sets (several hundred columns), then the default setting of 8MB for the
        max-storage-object-size may be too low. The inline-lobs also account in this size if batch contains them.
        The sizing for max-storage-object-size is in terms of serialized size, which will be much closer to the raw
        data size than the Java memory footprint estimation used for max-reserved-kb. max-storage-object-size should
        not be set too large relative to memory-buffer-space since it will reduce the performance of the memory buffer.
        The memory buffer supports only 1 concurrent writer for each max-storage-object-size of the memory-buffer-space
        -->
        <property name="maxStorageObjectSize" value="8388608"/>
        <!--
        uses direct byte buffer (off heap = true) or heap byte buffer (off heap = false)
        Take advantage of the BufferManager memory buffer to access system memory without allocating it to the heap.
        Setting memory-buffer-off-heap to "true" will allocate the Teiid memory buffer off heap. Depending on whether
        your installation is dedicated to Teiid and the amount of system memory available, this may be preferable to
        on-heap allocation. The primary benefit is additional memory usage for Teiid without additional garbage
        collection tuning. This becomes especially important in situations where more than 32GB of memory is desired
        for the VM. Note that when using off-heap allocation, the memory must still be available to the java process and
        that setting the value of memory-buffer-space too high may cause the VM to swap rather than reside in memory.
        With large off-heap buffer sizes (greater than several gigabytes) you may also need to adjust VM settings.
        -->
        <property name="memoryBufferOffHeap" value="false"/>
    </bean>

    <bean id="transactionManagerConfiguration" class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.impl.TransactionManagerConfigurationImpl" lazy-init="true">
        <!--
         a stable ASCII string that must uniquely identify this TM instance. It must not exceed 51 characters or it will be truncated.
         -->
        <property name="serverId" value="TeiidEmbeddedServer-TransactionManager"/>
        <!--
         Journal fragment file 1
         -->
        <property name="logPart1Filename" value="transactionBtm1.tlog"/>
        <!--
        Journal fragment file 2
        -->
        <property name="logPart2Filename" value="transactionBtm2.tlog"/>
        <!--
        whether saving journal fragment files to log directory
        -->
        <property name="saveLogFilesToLogDirectory" value="true"/>
        <!--
        Set the journal to be used to record transaction logs. This can be any of disk, null or a class name.
        The disk journal is a classic implementation using two fixed-size files and disk forces, the null journal just allows one to disable logging.
        Do not use the null journal on production as without transaction logs, atomicity cannot be guaranteed.
        -->
        <property name="journal" value="disk"/>
        <!--
        set logs forced to disk
        -->
        <property name="forcedWriteEnabled" value="true"/>
        <!--
        Are disk forces batched? Disabling batching can seriously lower the transaction manager's throughput.
        -->
        <property name="forceBatchingEnabled" value="true"/>
        <!--
        Should corrupted transactions log entries be skipped? Use only at last resort when all you have to recover is a pair of corrupted files.
        -->
        <property name="skipCorruptedLogs" value="true"/>
        <!--
        Set the Maximum size in megabytes of the journal fragments.
        Larger logs allow transactions to stay longer in-doubt but the TM pauses longer when a fragment is full.
        -->
        <property name="maxLogSizeInMb" value="2"/>
    </bean>

    <bean id="fileTranslator" class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.TranslatorConfig" lazy-init="true">
        <property name="productName" value="file"/>
        <property name="translatorName" value="file"/>
        <property name="translatorFactoryClass" value="org.teiid.translator.file.FileExecutionFactory"/>
    </bean>


    <bean id="serverConfig" class="com.jaspersoft.jasperserver.api.common.virtualdatasourcequery.teiid.ServerConfig" lazy-init="true">
        <!-- property name="transactionManagerJNDILookup" value="java:/comp/env/TransactionManager"/ -->
        <!-- property name="serverInit"><ref bean="serverInit"/></property -->
    </bean>

    <bean id="serverInit" class="com.jaspersoft.jasperserver.api.engine.common.virtualdatasourcequery.teiid.impl.TeiidServerInitImpl" lazy-init="true"/>

</beans>

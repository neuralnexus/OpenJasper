{"version":3,"sources":["webpack://jrs-ui/./runtime_dependencies/backbone.epoxy/backbone.epoxy.js"],"names":["module","exports","_","Backbone","modelMap","Epoxy","array","Array","prototype","isUndefined","isFunction","isObject","isArray","isModel","obj","Model","isCollection","Collection","blankMethod","mixins","mixin","extend","i","this","bindings","hasOwnProperty","_super","instance","method","args","apply","modelProps","deepModelSet","model","toSet","toReturn","stack","attribute","value","hasComputed","length","contains","join","c","set","concat","EpoxyComputedModel","name","params","delayInit","get","_get","_set","deps","init","constructor","attributes","options","pick","arguments","initComputeds","getCopy","clone","push","key","computedEvents","_setting","unset","result","silent","hasChanged","trigger","each","evt","toJSON","json","computed","destroy","clearComputeds","_c","computeds","keys","_init","addComputed","invoke","getter","setter","removeComputed","depsIndex","slice","call","dispose","modifyArray","modifyObject","property","change","Events","target","targets","binding","len","listenTo","bind","val","update","map","isEqual","stopListening","off","bindingSettings","optionText","optionValue","bindingCache","readAccessor","accessor","makeHandler","handler","bindingHandlers","attr","$element","checked","currentValue","prop","isRadio","index","indexOf","splice","toLowerCase","classes","enabled","className","toggleClass","collection","context","itemView","view","v","views","ItemView","models","mapCache","viewMap","cid","remove","collectionView","$children","children","eq","before","$el","append","sort","size","every","detach","frag","document","createDocumentFragment","appendChild","el","clean","id","css","disabled","html","e","optionsEmpty","d","optionsDefault","self","numOptions","option","opt","revisedValue","label","textAttr","valueAttr","template","raw","find","t","text","toggle","error","makeFilter","read","write","bindingFilters","all","any","none","not","format","str","replace","RegExp","select","condition","truthy","falsey","csv","String","split","integer","parseInt","decimal","parseFloat","allowedParams","events","addHandler","addFilter","config","settings","emptyCache","viewProps","addSourceToViewContext","source","prefix","accessViewDataAttribute","isDate","save","queryViewForSelector","selector","$elements","$","is","add","bindElementToView","declarations","handlers","filters","Function","union","handlerName","b","EpoxyBinding","accessViewContext","getDepsFromViewContext","values","tag","tagName","changable","triggers","reset","on","View","applyBindings","_b","setterOptions","removeBindings","sources","filter","viewModel","sourceName","bindingSources","elementDecs","getBinding","setBinding","pop","factory","require"],"mappings":"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","file":"_chunks/chunk.451.js","sourcesContent":["// Backbone.Epoxy\n\n// (c) 2013 Greg MacWilliam\n// Freely distributed under the MIT license\n// For usage and documentation:\n// http://epoxyjs.org\n\n(function(root, factory) {\n\n  if (typeof exports !== 'undefined') {\n    // Define as CommonJS export:\n    module.exports = factory(require(\"underscore\"), require(\"backbone\"));\n  } else if (typeof define === 'function' && define.amd) {\n    // Define as AMD:\n    define([\"underscore\", \"backbone\"], factory);\n  } else {\n    // Just run it:\n    factory(root._, root.Backbone);\n  }\n\n}(this, function(_, Backbone) {\n  \n  // Epoxy namespace:\n  var Epoxy = Backbone.Epoxy = {};\n\n  // Object-type utils:\n  var array = Array.prototype;\n  var isUndefined = _.isUndefined;\n  var isFunction = _.isFunction;\n  var isObject = _.isObject;\n  var isArray = _.isArray;\n  var isModel = function(obj) { return obj instanceof Backbone.Model; };\n  var isCollection = function(obj) { return obj instanceof Backbone.Collection; };\n  var blankMethod = function() {};\n\n  // Static mixins API:\n  // added as a static member to Epoxy class objects (Model & View);\n  // generates a set of class attributes for mixin with other objects.\n  var mixins = {\n    mixin: function(extend) {\n      extend = extend || {};\n\n      for (var i in this.prototype) {\n        // Skip override on pre-defined binding declarations:\n        if (i === 'bindings' && extend.bindings) continue;\n\n        // Assimilate non-constructor Epoxy prototype properties onto extended object:\n        if (this.prototype.hasOwnProperty(i) && i !== 'constructor') {\n          extend[i] = this.prototype[i];\n        }\n      }\n      return extend;\n    }\n  };\n  \n  // Calls method implementations of a super-class object:\n  function _super(instance, method, args) {\n    return instance._super.prototype[method].apply(instance, args);\n  }\n  \n  // Epoxy.Model\n  // -----------\n  var modelMap;\n  var modelProps = ['computeds'];\n\n  Epoxy.Model = Backbone.Model.extend({\n    _super: Backbone.Model,\n    \n    // Backbone.Model constructor override:\n    // configures computed model attributes around the underlying native Backbone model.\n    constructor: function(attributes, options) {\n      _.extend(this, _.pick(options||{}, modelProps));\n      _super(this, 'constructor', arguments);\n      this.initComputeds(attributes, options);\n    },\n\n    // Gets a copy of a model attribute value:\n    // Array and Object values will return a shallow copy,\n    // primitive values will be returned directly.\n    getCopy: function(attribute) {\n      return _.clone(this.get(attribute));\n    },\n\n    // Backbone.Model.get() override:\n    // provides access to computed attributes,\n    // and maps computed dependency references while establishing bindings.\n    get: function(attribute) {\n\n      // Automatically register bindings while building out computed dependency graphs:\n      modelMap && modelMap.push(['change:'+attribute, this]);\n\n      // Return a computed property value, if available:\n      if (this.hasComputed(attribute)) {\n        return this.c()[ attribute ].get();\n      }\n\n      // Default to native Backbone.Model get operation:\n      return _super(this, 'get', arguments);\n    },\n\n    // Backbone.Model.set() override:\n    // will process any computed attribute setters,\n    // and then pass along all results to the underlying model.\n    set: function(key, value, options) {\n      var params = key;\n\n      // Convert key/value arguments into {key:value} format:\n      if (params && !isObject(params)) {\n        params = {};\n        params[ key ] = value;\n      } else {\n        options = value;\n      }\n\n      // Default options definition:\n      options = options || {};\n      \n      // Create store for capturing computed change events:\n      var computedEvents = this._setting = [];\n      \n      // Attempt to set computed attributes while not unsetting:\n      if (!options.unset) {\n        // All param properties are tested against computed setters,\n        // properties set to computeds will be removed from the params table.\n        // Optionally, an computed setter may return key/value pairs to be merged into the set.\n        params = deepModelSet(this, params, {}, []);\n      }\n      \n      // Remove computed change events store:\n      delete this._setting;\n      \n      // Pass all resulting set params along to the underlying Backbone Model.\n      var result = _super(this, 'set', [params, options]);\n      \n      // Dispatch all outstanding computed events:\n      if (!options.silent) {\n        // Make sure computeds get a \"change\" event:\n        if (!this.hasChanged() && computedEvents.length) {\n          this.trigger('change', this);\n        }\n\n        // Trigger each individual computed attribute change:\n        // NOTE: computeds now officially fire AFTER basic \"change\"...\n        // We can't really fire them earlier without duplicating the Backbone \"set\" method here.\n        _.each(computedEvents, function(evt) {\n          this.trigger.apply(this, evt);\n        }, this);\n      }\n      return result;\n    },\n\n    // Backbone.Model.toJSON() override:\n    // adds a 'computed' option, specifying to include computed attributes.\n    toJSON: function(options) {\n      var json = _super(this, 'toJSON', arguments);\n\n      if (options && options.computed) {\n        _.each(this.c(), function(computed, attribute) {\n          json[ attribute ] = computed.value;\n        });\n      }\n\n      return json;\n    },\n\n    // Backbone.Model.destroy() override:\n    // clears all computed attributes before destroying.\n    destroy: function() {\n      this.clearComputeds();\n      return _super(this, 'destroy', arguments);\n    },\n\n    // Computed namespace manager:\n    // Allows the model to operate as a mixin.\n    c: function() {\n      return this._c || (this._c = {});\n    },\n\n    // Initializes the Epoxy model:\n    // called automatically by the native constructor,\n    // or may be called manually when adding Epoxy as a mixin.\n    initComputeds: function(attributes, options) {\n      this.clearComputeds();\n\n      // Resolve computeds hash, and extend it with any preset attribute keys:\n      // TODO: write test.\n      var computeds = _.result(this, 'computeds')||{};\n      computeds = _.extend(computeds, _.pick(attributes||{}, _.keys(computeds)));\n\n      // Add all computed attributes:\n      _.each(computeds, function(params, attribute) {\n        params._init = 1;\n        this.addComputed(attribute, params);\n      }, this);\n\n      // Initialize all computed attributes:\n      // all presets have been constructed and may reference each other now.\n      _.invoke(this.c(), 'init');\n    },\n\n    // Adds a computed attribute to the model:\n    // computed attribute will assemble and return customized values.\n    // @param attribute (string)\n    // @param getter (function) OR params (object)\n    // @param [setter (function)]\n    // @param [dependencies ...]\n    addComputed: function(attribute, getter, setter) {\n      this.removeComputed(attribute);\n\n      var params = getter;\n      var delayInit = params._init;\n\n      // Test if getter and/or setter are provided:\n      if (isFunction(getter)) {\n        var depsIndex = 2;\n\n        // Add getter param:\n        params = {};\n        params._get = getter;\n\n        // Test for setter param:\n        if (isFunction(setter)) {\n          params._set = setter;\n          depsIndex++;\n        }\n\n        // Collect all additional arguments as dependency definitions:\n        params.deps = array.slice.call(arguments, depsIndex);\n      }\n\n      // Create a new computed attribute:\n      this.c()[ attribute ] = new EpoxyComputedModel(this, attribute, params, delayInit);\n      return this;\n    },\n\n    // Tests the model for a computed attribute definition:\n    hasComputed: function(attribute) {\n      return this.c().hasOwnProperty(attribute);\n    },\n\n    // Removes an computed attribute from the model:\n    removeComputed: function(attribute) {\n      if (this.hasComputed(attribute)) {\n        this.c()[ attribute ].dispose();\n        delete this.c()[ attribute ];\n      }\n      return this;\n    },\n\n    // Removes all computed attributes:\n    clearComputeds: function() {\n      for (var attribute in this.c()) {\n        this.removeComputed(attribute);\n      }\n      return this;\n    },\n\n    // Internal array value modifier:\n    // performs array ops on a stored array value, then fires change.\n    // No action is taken if the specified attribute value is not an array.\n    modifyArray: function(attribute, method, options) {\n      var obj = this.get(attribute);\n\n      if (isArray(obj) && isFunction(array[method])) {\n        var args = array.slice.call(arguments, 2);\n        var result = array[ method ].apply(obj, args);\n        options = options || {};\n\n        if (!options.silent) {\n          this.trigger('change:'+attribute+' change', this, array, options);\n        }\n        return result;\n      }\n      return null;\n    },\n\n    // Internal object value modifier:\n    // sets new property values on a stored object value, then fires change.\n    // No action is taken if the specified attribute value is not an object.\n    modifyObject: function(attribute, property, value, options) {\n      var obj = this.get(attribute);\n      var change = false;\n\n      // If property is Object:\n      if (isObject(obj)) {\n\n        options = options || {};\n\n        // Delete existing property in response to undefined values:\n        if (isUndefined(value) && obj.hasOwnProperty(property)) {\n          delete obj[property];\n          change = true;\n        }\n        // Set new and/or changed property values:\n        else if (obj[ property ] !== value) {\n          obj[ property ] = value;\n          change = true;\n        }\n\n        // Trigger model change:\n        if (change && !options.silent) {\n          this.trigger('change:'+attribute+' change', this, obj, options);\n        }\n\n        // Return the modified object:\n        return obj;\n      }\n      return null;\n    }\n  }, mixins);\n\n  // Epoxy.Model -> Private\n  // ----------------------\n\n  // Model deep-setter:\n  // Attempts to set a collection of key/value attribute pairs to computed attributes.\n  // Observable setters may digest values, and then return mutated key/value pairs for inclusion into the set operation.\n  // Values returned from computed setters will be recursively deep-set, allowing computeds to set other computeds.\n  // The final collection of resolved key/value pairs (after setting all computeds) will be returned to the native model.\n  // @param model: target Epoxy model on which to operate.\n  // @param toSet: an object of key/value pairs to attempt to set within the computed model.\n  // @param toReturn: resolved non-ovservable attribute values to be returned back to the native model.\n  // @param trace: property stack trace (prevents circular setter loops).\n  function deepModelSet(model, toSet, toReturn, stack) {\n\n    // Loop through all setter properties:\n    for (var attribute in toSet) {\n      if (toSet.hasOwnProperty(attribute)) {\n\n        // Pull each setter value:\n        var value = toSet[ attribute ];\n\n        if (model.hasComputed(attribute)) {\n\n          // Has a computed attribute:\n          // comfirm attribute does not already exist within the stack trace.\n          if (!stack.length || !_.contains(stack, attribute)) {\n\n            // Non-recursive:\n            // set and collect value from computed attribute.\n            value = model.c()[attribute].set(value);\n\n            // Recursively set new values for a returned params object:\n            // creates a new copy of the stack trace for each new search branch.\n            if (value && isObject(value)) {\n              toReturn = deepModelSet(model, value, toReturn, stack.concat(attribute));\n            }\n\n          } else {\n            // Recursive:\n            // Throw circular reference error.\n            throw('Recursive setter: '+stack.join(' > '));\n          }\n\n        } else {\n          // No computed attribute:\n          // set the value to the keeper values.\n          toReturn[ attribute ] = value;\n        }\n      }\n    }\n\n    return toReturn;\n  }\n\n\n  // Epoxy.Model -> Computed\n  // -----------------------\n  // Computed objects store model values independently from the model's attributes table.\n  // Computeds define custom getter/setter functions to manage their value.\n\n  function EpoxyComputedModel(model, name, params, delayInit) {\n    params = params || {};\n\n    // Rewrite getter param:\n    if (params.get && isFunction(params.get)) {\n      params._get = params.get;\n    }\n\n    // Rewrite setter param:\n    if (params.set && isFunction(params.set)) {\n      params._set = params.set;\n    }\n\n    // Prohibit override of 'get()' and 'set()', then extend:\n    delete params.get;\n    delete params.set;\n    _.extend(this, params);\n\n    // Set model, name, and default dependencies array:\n    this.model = model;\n    this.name = name;\n    this.deps = this.deps || [];\n\n    // Skip init while parent model is initializing:\n    // Model will initialize in two passes...\n    // the first pass sets up all computed attributes,\n    // then the second pass initializes all bindings.\n    if (!delayInit) this.init();\n  }\n\n  _.extend(EpoxyComputedModel.prototype, Backbone.Events, {\n\n    // Initializes the computed's value and bindings:\n    // this method is called independently from the object constructor,\n    // allowing computeds to build and initialize in two passes by the parent model.\n    init: function() {\n\n      // Configure dependency map, then update the computed's value:\n      // All Epoxy.Model attributes accessed while getting the initial value\n      // will automatically register themselves within the model bindings map.\n      var bindings = {};\n      var deps = modelMap = [];\n      this.get(true);\n      modelMap = null;\n\n      // If the computed has dependencies, then proceed to binding it:\n      if (deps.length) {\n\n        // Compile normalized bindings table:\n        // Ultimately, we want a table of event types, each with an array of their associated targets:\n        // {'change:name':[<model1>], 'change:status':[<model1>,<model2>]}\n\n        // Compile normalized bindings map:\n        _.each(deps, function(value) {\n          var attribute = value[0];\n          var target = value[1];\n\n          // Populate event target arrays:\n          if (!bindings[attribute]) {\n            bindings[attribute] = [ target ];\n\n          } else if (!_.contains(bindings[attribute], target)) {\n            bindings[attribute].push(target);\n          }\n        });\n\n        // Bind all event declarations to their respective targets:\n        _.each(bindings, function(targets, binding) {\n          for (var i=0, len=targets.length; i < len; i++) {\n            this.listenTo(targets[i], binding, _.bind(this.get, this, true));\n          }\n        }, this);\n      }\n    },\n\n    // Gets an attribute value from the parent model.\n    val: function(attribute) {\n      return this.model.get(attribute);\n    },\n\n    // Gets the computed's current value:\n    // Computed values flagged as dirty will need to regenerate themselves.\n    // Note: 'update' is strongly checked as TRUE to prevent unintended arguments (handler events, etc) from qualifying.\n    get: function(update) {\n      if (update === true && this._get) {\n        var val = this._get.apply(this.model, _.map(this.deps, this.val, this));\n        this.change(val);\n      }\n      return this.value;\n    },\n\n    // Sets the computed's current value:\n    // computed values (have a custom getter method) require a custom setter.\n    // Custom setters should return an object of key/values pairs;\n    // key/value pairs returned to the parent model will be merged into its main .set() operation.\n    set: function(val) {\n      if (this._get) {\n        if (this._set) return this._set.apply(this.model, arguments);\n        else throw('Cannot set read-only computed attribute.');\n      }\n      this.change(val);\n      return null;\n    },\n\n    // Changes the computed's value:\n    // new values are cached, then fire an update event.\n    change: function(value) {\n      if (!_.isEqual(value, this.value)) {\n        this.value = value;\n        var evt = ['change:'+this.name, this.model, value];\n        \n        if (this.model._setting) {\n          this.model._setting.push(evt);\n        } else {\n          evt[0] += ' change';\n          this.model.trigger.apply(this.model, evt);\n        }\n      }\n    },\n\n    // Disposal:\n    // cleans up events and releases references.\n    dispose: function() {\n      this.stopListening();\n      this.off();\n      this.model = this.value = null;\n    }\n  });\n\n\n  // Epoxy.binding -> Binding API\n  // ----------------------------\n\n  var bindingSettings = {\n    optionText: 'label',\n    optionValue: 'value'\n  };\n\n\n  // Cache for storing binding parser functions:\n  // Cuts down on redundancy when building repetitive binding views.\n  var bindingCache = {};\n\n\n  // Reads value from an accessor:\n  // Accessors come in three potential forms:\n  // => A function to call for the requested value.\n  // => An object with a collection of attribute accessors.\n  // => A primitive (string, number, boolean, etc).\n  // This function unpacks an accessor and returns its underlying value(s).\n\n  function readAccessor(accessor) {\n\n    if (isFunction(accessor)) {\n      // Accessor is function: return invoked value.\n      return accessor();\n    }\n    else if (isObject(accessor)) {\n      // Accessor is object/array: return copy with all attributes read.\n      accessor = _.clone(accessor);\n\n      _.each(accessor, function(value, key) {\n        accessor[ key ] = readAccessor(value);\n      });\n    }\n    // return formatted value, or pass through primitives:\n    return accessor;\n  }\n\n\n  // Binding Handlers\n  // ----------------\n  // Handlers define set/get methods for exchanging data with the DOM.\n\n  // Formatting function for defining new handler objects:\n  function makeHandler(handler) {\n    return isFunction(handler) ? {set: handler} : handler;\n  }\n\n  var bindingHandlers = {\n    // Attribute: write-only. Sets element attributes.\n    attr: makeHandler(function($element, value) {\n      $element.attr(value);\n    }),\n\n    // Checked: read-write. Toggles the checked status of a form element.\n    checked: makeHandler({\n      get: function($element, currentValue) {\n        var checked = !!$element.prop('checked');\n        var value = $element.val();\n\n        if (this.isRadio($element)) {\n          // Radio button: return value directly.\n          return value;\n\n        } else if (isArray(currentValue)) {\n          // Checkbox array: add/remove value from list.\n          currentValue = currentValue.slice();\n          var index = _.indexOf(currentValue, value);\n\n          if (checked && index < 0) {\n            currentValue.push(value);\n          } else if (!checked && index > -1) {\n            currentValue.splice(index, 1);\n          }\n          return currentValue;\n        }\n        // Checkbox: return boolean toggle.\n        return checked;\n      },\n      set: function($element, value) {\n        // Default as loosely-typed boolean:\n        var checked = !!value;\n\n        if (this.isRadio($element)) {\n          // Radio button: match checked state to radio value.\n          checked = (value == $element.val());\n\n        } else if (isArray(value)) {\n          // Checkbox array: match checked state to checkbox value in array contents.\n          checked = _.contains(value, $element.val());\n        }\n\n        // Set checked property to element:\n        $element.prop('checked', checked);\n      },\n      // Is radio button: avoids '.is(\":radio\");' check for basic Zepto compatibility.\n      isRadio: function($element) {\n        return $element.attr('type').toLowerCase() === 'radio';\n      }\n    }),\n\n    // Class Name: write-only. Toggles a collection of class name definitions.\n    classes: makeHandler(function($element, value) {\n      _.each(value, function(enabled, className) {\n        $element.toggleClass(className, !!enabled);\n      });\n    }),\n\n    // Collection: write-only. Manages a list of views bound to a Backbone.Collection.\n    collection: makeHandler({\n      init: function($element, collection, context, bindings) {\n        this.i = bindings.itemView ? this.view[bindings.itemView] : this.view.itemView;\n        if (!isCollection(collection)) throw('Binding \"collection\" requires a Collection.');\n        if (!isFunction(this.i)) throw('Binding \"collection\" requires an itemView.');\n        this.v = {};\n      },\n      set: function($element, collection, target) {\n\n        var view;\n        var views = this.v;\n        var ItemView = this.i;\n        var models = collection.models;\n\n        // Cache and reset the current dependency graph state:\n        // sub-views may be created (each with their own dependency graph),\n        // therefore we need to suspend the working graph map here before making children...\n        var mapCache = viewMap;\n        viewMap = null;\n\n        // Default target to the bound collection object:\n        // during init (or failure), the binding will reset.\n        target = target || collection;\n\n        if (isModel(target)) {\n\n          // ADD/REMOVE Event (from a Model):\n          // test if view exists within the binding...\n          if (!views.hasOwnProperty(target.cid)) {\n\n            // Add new view:\n            views[ target.cid ] = view = new ItemView({model: target, collectionView: this.view});\n            var index = _.indexOf(models, target);\n            var $children = $element.children();\n\n            // Attempt to add at proper index,\n            // otherwise just append into the element.\n            if (index < $children.length) {\n              $children.eq(index).before(view.$el);\n            } else {\n              $element.append(view.$el);\n            }\n\n          } else {\n\n            // Remove existing view:\n            views[ target.cid ].remove();\n            delete views[ target.cid ];\n          }\n\n        } else if (isCollection(target)) {\n\n          // SORT/RESET Event (from a Collection):\n          // First test if we're sorting...\n          // (number of models has not changed and all their views are present)\n          var sort = models.length === _.size(views) && collection.every(function(model) {\n            return views.hasOwnProperty(model.cid);\n          });\n\n          // Hide element before manipulating:\n          $element.children().detach();\n          var frag = document.createDocumentFragment();\n\n          if (sort) {\n            // Sort existing views:\n            collection.each(function(model) {\n              frag.appendChild(views[model.cid].el);\n            });\n\n          } else {\n            // Reset with new views:\n            this.clean();\n            collection.each(function(model) {\n              views[ model.cid ] = view = new ItemView({model: model, collectionView: this.view});\n              frag.appendChild(view.el);\n            }, this);\n          }\n\n          $element.append(frag);\n        }\n\n        // Restore cached dependency graph configuration:\n        viewMap = mapCache;\n      },\n      clean: function() {\n        for (var id in this.v) {\n          if (this.v.hasOwnProperty(id)) {\n            this.v[ id ].remove();\n            delete this.v[ id ];\n          }\n        }\n      }\n    }),\n\n    // CSS: write-only. Sets a collection of CSS styles to an element.\n    css: makeHandler(function($element, value) {\n      $element.css(value);\n    }),\n\n    // Disabled: write-only. Sets the 'disabled' status of a form element (true :: disabled).\n    disabled: makeHandler(function($element, value) {\n      $element.prop('disabled', !!value);\n    }),\n\n    // Enabled: write-only. Sets the 'disabled' status of a form element (true :: !disabled).\n    enabled: makeHandler(function($element, value) {\n      $element.prop('disabled', !value);\n    }),\n\n    // HTML: write-only. Sets the inner HTML value of an element.\n    html: makeHandler(function($element, value) {\n      $element.html(value);\n    }),\n\n    // Options: write-only. Sets option items to a <select> element, then updates the value.\n    options: makeHandler({\n      init: function($element, value, context, bindings) {\n        this.e = bindings.optionsEmpty;\n        this.d = bindings.optionsDefault;\n        this.v = bindings.value;\n      },\n      set: function($element, value) {\n\n        // Pre-compile empty and default option values:\n        // both values MUST be accessed, for two reasons:\n        // 1) we need to need to guarentee that both values are reached for mapping purposes.\n        // 2) we'll need their values anyway to determine their defined/undefined status.\n        var self = this;\n        var optionsEmpty = readAccessor(self.e);\n        var optionsDefault = readAccessor(self.d);\n        var currentValue = readAccessor(self.v);\n        var options = isCollection(value) ? value.models : value;\n        var numOptions = options.length;\n        var enabled = true;\n        var html = '';\n\n        // No options or default, and has an empty options placeholder:\n        // display placeholder and disable select menu.\n        if (!numOptions && !optionsDefault && optionsEmpty) {\n\n          html += self.opt(optionsEmpty, numOptions);\n          enabled = false;\n\n        } else {\n          // Try to populate default option and options list:\n\n          // Configure list with a default first option, if defined:\n          if (optionsDefault) {\n            options = [ optionsDefault ].concat(options);\n          }\n\n          // Create all option items:\n          _.each(options, function(option, index) {\n            html += self.opt(option, numOptions);\n          });\n        }\n\n        // Set new HTML to the element and toggle disabled status:\n        $element.html(html).prop('disabled', !enabled).val(currentValue);\n\n        // Pull revised value with new options selection state:\n        var revisedValue = $element.val();\n\n        // Test if the current value was successfully applied:\n        // if not, set the new selection state into the model.\n        if (self.v && !_.isEqual(currentValue, revisedValue)) {\n          self.v(revisedValue);\n        }\n      },\n      opt: function(option, numOptions) {\n        // Set both label and value as the raw option object by default:\n        var label = option;\n        var value = option;\n        var textAttr = bindingSettings.optionText;\n        var valueAttr = bindingSettings.optionValue;\n\n        // Dig deeper into label/value settings for non-primitive values:\n        if (isObject(option)) {\n          // Extract a label and value from each object:\n          // a model's 'get' method is used to access potential computed values.\n          label = isModel(option) ? option.get(textAttr) : option[ textAttr ];\n          value = isModel(option) ? option.get(valueAttr) : option[ valueAttr ];\n        }\n\n        return ['<option value=\"', value, '\">', label, '</option>'].join('');\n      },\n      clean: function() {\n        this.d = this.e = this.v = 0;\n      }\n    }),\n\n    // Template: write-only. Renders the bound element with an Underscore template.\n    template: makeHandler({\n      init: function($element, value, context) {\n        var raw = $element.find('script,template');\n        this.t = _.template(raw.length ? raw.html() : $element.html());\n\n        // If an array of template attributes was provided,\n        // then replace array with a compiled hash of attribute accessors:\n        if (isArray(value)) {\n          return _.pick(context, value);\n        }\n      },\n      set: function($element, value) {\n        value = isModel(value) ? value.toJSON({computed:true}) : value;\n        $element.html(this.t(value));\n      },\n      clean: function() {\n        this.t = null;\n      }\n    }),\n\n    // Text: read-write. Gets and sets the text value of an element.\n    text: makeHandler({\n      get: function($element) {\n        return $element.text();\n      },\n      set: function($element, value) {\n        $element.text(value);\n      }\n    }),\n\n    // Toggle: write-only. Toggles the visibility of an element.\n    toggle: makeHandler(function($element, value) {\n      $element.toggle(!!value);\n    }),\n\n    // Value: read-write. Gets and sets the value of a form element.\n    value: makeHandler({\n      get: function($element) {\n        return $element.val();\n      },\n      set: function($element, value) {\n        try {\n          if ($element.val() + '' != value + '') $element.val(value);\n        } catch (error) {\n          // Error setting value: IGNORE.\n          // This occurs in IE6 while attempting to set an undefined multi-select option.\n          // unfortuantely, jQuery doesn't gracefully handle this error for us.\n          // remove this try/catch block when IE6 is officially deprecated.\n        }\n      }\n    })\n  };\n\n\n  // Binding Filters\n  // ---------------\n  // Filters are special binding handlers that may be invoked while binding;\n  // they will return a wrapper function used to modify how accessors are read.\n\n  // Partial application wrapper for creating binding filters:\n  function makeFilter(handler) {\n    return function() {\n      var params = arguments;\n      var read = isFunction(handler) ? handler : handler.get;\n      var write = handler.set;\n      return function(value) {\n        return isUndefined(value) ?\n          read.apply(this, _.map(params, readAccessor)) :\n          params[0]((write ? write : read).call(this, value));\n      };\n    };\n  }\n\n  var bindingFilters = {\n    // Positive collection assessment [read-only]:\n    // Tests if all of the provided accessors are truthy (and).\n    all: makeFilter(function() {\n      var params = arguments;\n      for (var i=0, len=params.length; i < len; i++) {\n        if (!params[i]) return false;\n      }\n      return true;\n    }),\n\n    // Partial collection assessment [read-only]:\n    // tests if any of the provided accessors are truthy (or).\n    any: makeFilter(function() {\n      var params = arguments;\n      for (var i=0, len=params.length; i < len; i++) {\n        if (params[i]) return true;\n      }\n      return false;\n    }),\n\n    // Collection length accessor [read-only]:\n    // assumes accessor value to be an Array or Collection; defaults to 0.\n    length: makeFilter(function(value) {\n      return value.length || 0;\n    }),\n\n    // Negative collection assessment [read-only]:\n    // tests if none of the provided accessors are truthy (and not).\n    none: makeFilter(function() {\n      var params = arguments;\n      for (var i=0, len=params.length; i < len; i++) {\n        if (params[i]) return false;\n      }\n      return true;\n    }),\n\n    // Negation [read-only]:\n    not: makeFilter(function(value) {\n      return !value;\n    }),\n\n    // Formats one or more accessors into a text string:\n    // ('$1 $2 did $3', firstName, lastName, action)\n    format: makeFilter(function(str) {\n      var params = arguments;\n\n      for (var i=1, len=params.length; i < len; i++) {\n        // TODO: need to make something like this work: (?<!\\\\)\\$1\n        str = str.replace(new RegExp('\\\\$'+i, 'g'), params[i]);\n      }\n      return str;\n    }),\n\n    // Provides one of two values based on a ternary condition:\n    // uses first param (a) as condition, and returns either b (truthy) or c (falsey).\n    select: makeFilter(function(condition, truthy, falsey) {\n      return condition ? truthy : falsey;\n    }),\n\n    // CSV array formatting [read-write]:\n    csv: makeFilter({\n      get: function(value) {\n        value = String(value);\n        return value ? value.split(',') : [];\n      },\n      set: function(value) {\n        return isArray(value) ? value.join(',') : value;\n      }\n    }),\n\n    // Integer formatting [read-write]:\n    integer: makeFilter(function(value) {\n      return value ? parseInt(value, 10) : 0;\n    }),\n\n    // Float formatting [read-write]:\n    decimal: makeFilter(function(value) {\n      return value ? parseFloat(value) : 0;\n    })\n  };\n\n  // Define allowed binding parameters:\n  // These params may be included in binding handlers without throwing errors.\n  var allowedParams = {\n    events: 1,\n    itemView: 1,\n    optionsDefault: 1,\n    optionsEmpty: 1\n  };\n\n  // Define binding API:\n  Epoxy.binding = {\n    allowedParams: allowedParams,\n    addHandler: function(name, handler) {\n      bindingHandlers[ name ] = makeHandler(handler);\n    },\n    addFilter: function(name, handler) {\n      bindingFilters[ name ] = makeFilter(handler);\n    },\n    config: function(settings) {\n      _.extend(bindingSettings, settings);\n    },\n    emptyCache: function() {\n      bindingCache = {};\n    }\n  };\n\n\n  // Epoxy.View\n  // ----------\n  var viewMap;\n  var viewProps = ['viewModel', 'bindings', 'bindingFilters', 'bindingHandlers', 'bindingSources', 'computeds'];\n\n  Epoxy.View = Backbone.View.extend({\n    _super: Backbone.View,\n    \n    // Backbone.View constructor override:\n    // sets up binding controls around call to super.\n    constructor: function(options) {\n      _.extend(this, _.pick(options||{}, viewProps));\n      _super(this, 'constructor', arguments);\n      this.applyBindings();\n    },\n\n    // Bindings list accessor:\n    b: function() {\n      return this._b || (this._b = []);\n    },\n\n    // Bindings definition:\n    // this setting defines a DOM attribute name used to query for bindings.\n    // Alternatively, this be replaced with a hash table of key/value pairs,\n    // where 'key' is a DOM query and 'value' is its binding declaration.\n    bindings: 'data-bind',\n\n    // Setter options:\n    // Defines an optional hashtable of options to be passed to setter operations.\n    // Accepts a custom option '{save:true}' that will write to the model via \".save()\".\n    setterOptions: null,\n\n    // Compiles a model context, then applies bindings to the view:\n    // All Model->View relationships will be baked at the time of applying bindings;\n    // changes in configuration to source attributes or view bindings will require a complete re-bind.\n    applyBindings: function() {\n      this.removeBindings();\n\n      var self = this;\n      var sources = _.clone(_.result(self, 'bindingSources'));\n      var declarations = self.bindings;\n      var options = self.setterOptions;\n      var handlers = _.clone(bindingHandlers);\n      var filters = _.clone(bindingFilters);\n      var context = self._c = {};\n\n      // Compile a complete set of binding handlers for the view:\n      // mixes all custom handlers into a copy of default handlers.\n      // Custom handlers defined as plain functions are registered as read-only setters.\n      _.each(_.result(self, 'bindingHandlers')||{}, function(handler, name) {\n          handlers[ name ] = makeHandler(handler);\n      });\n\n      // Compile a complete set of binding filters for the view:\n      // mixes all custom filters into a copy of default filters.\n      _.each(_.result(self, 'bindingFilters')||{}, function(filter, name) {\n          filters[ name ] = makeFilter(filter);\n      });\n\n      // Add native 'model' and 'collection' data sources:\n      self.model = addSourceToViewContext(self, context, options, 'model');\n      self.viewModel = addSourceToViewContext(self, context, options, 'viewModel');\n      self.collection = addSourceToViewContext(self, context, options, 'collection');\n\n      // Support legacy \"collection.view\" API for rendering list items:\n      // **Deprecated: will be removed after next release*.*\n      if (self.collection && self.collection.view) {\n        self.itemView = self.collection.view;\n      }\n\n      // Add all additional data sources:\n      if (sources) {\n        _.each(sources, function(source, sourceName) {\n          sources[ sourceName ] = addSourceToViewContext(sources, context, options, sourceName, sourceName);\n        });\n\n        // Reapply resulting sources to view instance.\n        self.bindingSources = sources;\n      }\n\n      // Add all computed view properties:\n      _.each(_.result(self, 'computeds')||{}, function(computed, name) {\n        var getter = isFunction(computed) ? computed : computed.get;\n        var setter = computed.set;\n        var deps = computed.deps;\n\n        context[ name ] = function(value) {\n          return (!isUndefined(value) && setter) ?\n            setter.call(self, value) :\n            getter.apply(self, getDepsFromViewContext(self._c, deps));\n        };\n      });\n\n      // Create all bindings:\n      // bindings are created from an object hash of query/binding declarations,\n      // OR based on queried DOM attributes.\n      if (isObject(declarations)) {\n\n        // Object declaration method:\n        // {'span.my-element': 'text:attribute'}\n\n        _.each(declarations, function(elementDecs, selector) {\n          // Get DOM jQuery reference:\n          var $element = queryViewForSelector(self, selector);\n\n          // Ignore empty DOM queries (without errors):\n          if ($element.length) {\n            bindElementToView(self, $element, elementDecs, context, handlers, filters);\n          }\n        });\n\n      } else {\n\n        // DOM attributes declaration method:\n        // <span data-bind='text:attribute'></span>\n\n        // Create bindings for each matched element:\n        queryViewForSelector(self, '['+declarations+']').each(function() {\n          var $element = Backbone.$(this);\n          bindElementToView(self, $element, $element.attr(declarations), context, handlers, filters);\n        });\n      }\n    },\n\n    // Gets a value from the binding context:\n    getBinding: function(attribute) {\n      return accessViewContext(this._c, attribute);\n    },\n\n    // Sets a value to the binding context:\n    setBinding: function(attribute, value) {\n      return accessViewContext(this._c, attribute, value);\n    },\n\n    // Disposes of all view bindings:\n    removeBindings: function() {\n      this._c = null;\n\n      if (this._b) {\n        while (this._b.length) {\n          this._b.pop().dispose();\n        }\n      }\n    },\n\n    // Backbone.View.remove() override:\n    // unbinds the view before performing native removal tasks.\n    remove: function() {\n      this.removeBindings();\n      _super(this, 'remove', arguments);\n    }\n\n  }, mixins);\n\n  // Epoxy.View -> Private\n  // ---------------------\n\n  // Adds a data source to a view:\n  // Data sources are Backbone.Model and Backbone.Collection instances.\n  // @param source: a source instance, or a function that returns a source.\n  // @param context: the working binding context. All bindings in a view share a context.\n  function addSourceToViewContext(source, context, options, name, prefix) {\n\n    // Resolve source instance:\n    source = _.result(source, name);\n\n    // Ignore missing sources, and invoke non-instances:\n    if (!source) return;\n\n    // Add Backbone.Model source instance:\n    if (isModel(source)) {\n\n      // Establish source prefix:\n      prefix = prefix ? prefix+'_' : '';\n\n      // Create a read-only accessor for the model instance:\n      context['$'+name] = function() {\n        viewMap && viewMap.push([source, 'change']);\n        return source;\n      };\n\n      // Compile all model attributes as accessors within the context:\n      _.each(source.toJSON({computed:true}), function(value, attribute) {\n\n        // Create named accessor functions:\n        // -> Attributes from 'view.model' use their normal names.\n        // -> Attributes from additional sources are named as 'source_attribute'.\n        context[prefix+attribute] = function(value) {\n          return accessViewDataAttribute(source, attribute, value, options);\n        };\n      });\n    }\n    // Add Backbone.Collection source instance:\n    else if (isCollection(source)) {\n\n      // Create a read-only accessor for the collection instance:\n      context['$'+name] = function() {\n        viewMap && viewMap.push([source, 'reset add remove sort update']);\n        return source;\n      };\n    }\n\n    // Return original object, or newly constructed data source:\n    return source;\n  }\n\n  // Attribute data accessor:\n  // exchanges individual attribute values with model sources.\n  // This function is separated out from the accessor creation process for performance.\n  // @param source: the model data source to interact with.\n  // @param attribute: the model attribute to read/write.\n  // @param value: the value to set, or 'undefined' to get the current value.\n  function accessViewDataAttribute(source, attribute, value, options) {\n    // Register the attribute to the bindings map, if enabled:\n    viewMap && viewMap.push([source, 'change:'+attribute]);\n\n    // Set attribute value when accessor is invoked with an argument:\n    if (!isUndefined(value)) {\n\n      // Set Object (non-null, non-array) hashtable value:\n      if (!isObject(value) || isArray(value) || _.isDate(value)) {\n        var val = value;\n        value = {};\n        value[attribute] = val;\n      }\n\n      // Set value:\n      return options && options.save ? source.save(value, options) : source.set(value, options);\n    }\n\n    // Get the attribute value by default:\n    return source.get(attribute);\n  }\n\n  // Queries element selectors within a view:\n  // matches elements within the view, and the view's container element.\n  function queryViewForSelector(view, selector) {\n    if (selector === ':el') return view.$el;\n    var $elements = view.$(selector);\n\n    // Include top-level view in bindings search:\n    if (view.$el.is(selector)) {\n      $elements = $elements.add(view.$el);\n    }\n\n    return $elements;\n  }\n\n  // Binds an element into a view:\n  // The element's declarations are parsed, then a binding is created for each declared handler.\n  // @param view: the parent View to bind into.\n  // @param $element: the target element (as jQuery) to bind.\n  // @param declarations: the string of binding declarations provided for the element.\n  // @param context: a compiled binding context with all availabe view data.\n  // @param handlers: a compiled handlers table with all native/custom handlers.\n  function bindElementToView(view, $element, declarations, context, handlers, filters) {\n\n    // Parse localized binding context:\n    // parsing function is invoked with 'filters' and 'context' properties made available,\n    // yeilds a native context object with element-specific bindings defined.\n    try {\n      var parserFunct = bindingCache[declarations] || (bindingCache[declarations] = new Function('$f','$c','with($f){with($c){return{'+ declarations +'}}}'));\n      var bindings = parserFunct(filters, context);\n    } catch (error) {\n      throw('Error parsing bindings: \"'+declarations +'\"\\n>> '+error);\n    }\n\n    // Format the 'events' option:\n    // include events from the binding declaration along with a default 'change' trigger,\n    // then format all event names with a '.epoxy' namespace.\n    var events = _.map(_.union(bindings.events || [], ['change']), function(name) {\n      return name+'.epoxy';\n    }).join(' ');\n\n    // Apply bindings from native context:\n    _.each(bindings, function(accessor, handlerName) {\n\n      // Validate that each defined handler method exists before binding:\n      if (handlers.hasOwnProperty(handlerName)) {\n        // Create and add binding to the view's list of handlers:\n        view.b().push(new EpoxyBinding(view, $element, handlers[handlerName], accessor, events, context, bindings));\n      } else if (!allowedParams.hasOwnProperty(handlerName)) {\n        throw('binding handler \"'+ handlerName +'\" is not defined.');\n      }\n    });\n  }\n\n  // Gets and sets view context data attributes:\n  // used by the implementations of \"getBinding\" and \"setBinding\".\n  function accessViewContext(context, attribute, value) {\n    if (context && context.hasOwnProperty(attribute)) {\n      return isUndefined(value) ? readAccessor(context[attribute]) : context[attribute](value);\n    }\n  }\n\n  // Accesses an array of dependency properties from a view context:\n  // used for mapping view dependencies by manual declaration.\n  function getDepsFromViewContext(context, attributes) {\n    var values = [];\n    if (attributes && context) {\n      for (var i=0, len=attributes.length; i < len; i++) {\n        values.push(attributes[i] in context ? context[ attributes[i] ]() : null);\n      }\n    }\n    return values;\n  }\n\n\n  // Epoxy.View -> Binding\n  // ---------------------\n  // The binding object connects an element to a bound handler.\n  // @param view: the view object this binding is attached to.\n  // @param $element: the target element (as jQuery) to bind.\n  // @param handler: the handler object to apply (include all handler methods).\n  // @param accessor: an accessor method from the binding context that exchanges data with the model.\n  // @param events: \n  // @param context: \n  // @param bindings: \n  function EpoxyBinding(view, $element, handler, accessor, events, context, bindings) {\n    \n    var self = this;\n    var tag = ($element[0].tagName).toLowerCase();\n    var changable = (tag == 'input' || tag == 'select' || tag == 'textarea' || $element.prop('contenteditable') == 'true');\n    var triggers = [];\n    var reset = function(target) {\n      self.$el && self.set(self.$el, readAccessor(accessor), target);\n    };\n    \n    self.view = view;\n    self.$el = $element;\n    self.evt = events;\n    _.extend(self, handler);\n\n    // Initialize the binding:\n    // allow the initializer to redefine/modify the attribute accessor if needed.\n    accessor = self.init(self.$el, readAccessor(accessor), context, bindings) || accessor;\n\n    // Set default binding, then initialize & map bindings:\n    // each binding handler is invoked to populate its initial value.\n    // While running a handler, all accessed attributes will be added to the handler's dependency map.\n    viewMap = triggers;\n    reset();\n    viewMap = null;\n\n    // Configure READ/GET-able binding. Requires:\n    // => Form element.\n    // => Binding handler has a getter method.\n    // => Value accessor is a function.\n    if (changable && handler.get && isFunction(accessor)) {\n      self.$el.on(events, function(evt) {\n        accessor(self.get(self.$el, readAccessor(accessor), evt));\n      });\n    }\n\n    // Configure WRITE/SET-able binding. Requires:\n    // => One or more events triggers.\n    if (triggers.length) {\n      for (var i=0, len=triggers.length; i < len; i++) {\n        self.listenTo(triggers[i][0], triggers[i][1], reset);\n      }\n    }\n  }\n\n  _.extend(EpoxyBinding.prototype, Backbone.Events, {\n\n    // Pass-through binding methods:\n    // for override by actual implementations.\n    init: blankMethod,\n    get: blankMethod,\n    set: blankMethod,\n    clean: blankMethod,\n\n    // Destroys the binding:\n    // all events and managed sub-views are killed.\n    dispose: function() {\n      this.clean();\n      this.stopListening();\n      this.$el.off(this.evt);\n      this.$el = this.view = null;\n    }\n  });\n\n  return Epoxy;\n}));\n"],"sourceRoot":""}